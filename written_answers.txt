Answers for parts  1 - 5
Enter your answers in the designated location. Do NOT remove lines that start
with '=' signs. Removing these lines will break our grading scrips and will
result in 0 points. Also, keep lines to a max of 80 chars long (you do not
need to worry if the top command is longer than 80 chars). Also, please limit
your answers to about 40 words.

================================== P1Q1 start ==================================
Describe how you created the 70%/30% split. 
    - Include the command lines you executed
    - Indicate if you needed root privileges for any of those commands
    - Include the top output

    /* TODO */ 

=================================== P1Q1 end ===================================

================================== P1Q2 start ==================================
Describe how you created a real-time priority task.
    - Include the command lines you executed
    - Indicate if you needed root privileges for any of those commands
    - Include the top output

    /* TODO */ 

=================================== P1Q2 end ===================================



================================== P2Q1 start ==================================
The output of diff or diffconfig when comparing the config files for your 
mainline fallback kernel and your MuQSS kernel

output of diffconfig:
    -CFS_BANDWIDTH y
	-CGROUP_CPUACCT y
	-FAIR_GROUP_SCHED y
	-NUMA_BALANCING y
	-NUMA_BALANCING_DEFAULT_ENABLED y
	-RT_GROUP_SCHED n
	-SCHED_AUTOGROUP y
	+RQ_MC y
	+RQ_NONE n
	+RQ_SMP n
	+RQ_SMT n
	+SCHED_MUQSS y
	+SHARERQ 2
	+SMT_NICE y

=================================== P2Q1 end ===================================

================================== P2Q2 start ==================================
Indicate you successfully patched, built, and booted into your MuQSS-enabled 
Linux kernel.

	[    0.194489] MuQSS locality CPU 0 to 1: 2
	[    0.194491] MuQSS locality CPU 0 to 2: 2
	[    0.194491] MuQSS locality CPU 0 to 3: 2
	[    0.194492] MuQSS locality CPU 1 to 2: 2
	[    0.194493] MuQSS locality CPU 1 to 3: 2
	[    0.194494] MuQSS locality CPU 2 to 3: 2
	[    0.196027] MuQSS runqueue share type MC total runqueues: 29
	[    0.876152] MuQSS CPU scheduler v0.180 by Con Kolivas.

=================================== P2Q2 end ===================================



================================== P3Q1 start ==================================
Describe how you created the 70%/30% split. 
    - Include the command lines you executed
    - Indicate if you needed root privileges for any of those commands
    - How were the results different from P1Q1, if at all.

    By using muqss, p1 task 1's program the ratio changed slightly. In muqss,
	the ratio is roughly 65%:35%. But at first, one or two process have the whole
	cpu, and after a while, the ratio changed to 65%:35%.

	at last:
	top - 01:56:25 up  5:43,  3 users,  load average: 10.07, 10.03, 9.99
	Tasks: 178 total,  11 running, 167 sleeping,   0 stopped,   0 zombie
	%Cpu0  :   0.0/0.0     0[                                                   ]
	%Cpu1  :   0.0/0.0     0[                                                   ]
	%Cpu2  : 100.0/0.0   100[|||||||||||||||||||||||||||||||||||||||||||||||||||]
	%Cpu3  :   0.0/0.0     0[                                                   ]
	MiB Mem :   7973.6 total,   5361.6 free,    648.2 used,   1963.8 buff/cache
	MiB Swap:   8190.0 total,   8190.0 free,      0.0 used.   7012.2 avail Mem 

	PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                                            
	3974 bateman    1   0    2276    740    680 S   0.0   0.0   0:00.00 myprogram                                                                             
	3975 bateman   10  10    2276     76      0 R  14.3   0.0  15:58.56 myprogram                                                                             
	3976 bateman   16  10    2276     76      0 R  14.3   0.0   1:22.98 myprogram                                                                             
	3977 bateman   12  10    2276     76      0 R  14.3   0.0   1:21.09 myprogram                                                                             
	3978 bateman   14  10    2276     76      0 R  14.3   0.0   1:21.75 myprogram                                                                             
	3979 bateman   15  10    2276     76      0 R  14.3   0.0   1:21.10 myprogram                                                                             
	3980 bateman   25  14    2276     76      0 R   7.0   0.0   0:40.93 myprogram                                                                             
	3981 bateman   11  14    2276     76      0 R   6.6   0.0   0:40.54 myprogram                                                                             
	3982 bateman   21  14    2276     76      0 R   7.3   0.0   2:41.15 myprogram                                                                             
	3983 bateman   16  14    2276     76      0 R   7.3   0.0   1:23.76 myprogram                                                                             
	3984 bateman   19  14    2276     76      0 R   7.0   0.0   1:23.68 myprogram
	

=================================== P3Q1 end ===================================

================================== P3Q2 start ==================================
Describe how you created a real-time priority task. 
    - Include the command lines you executed
    - Indicate if you needed root privileges for any of those commands
    - How were the results different from P1Q2, if at all.

    this part has the same behavior as part1 taks2.

=================================== P3Q2 end ===================================

================================== P3Q3 start ==================================
MuQSS features unprivileged real-time tasks. Perform the previous task with and
without root privileges, and describe the differences. 

    In this part, the last process has roughly 80% of the cpu and the first 10 processes
	share the rest of cpu.

	the output of top:
	top - 03:08:30 up  6:24,  3 users,  load average: 11.07, 11.96, 11.92
	Tasks: 186 total,  12 running, 174 sleeping,   0 stopped,   0 zombie
	%Cpu0  :   0.3/0.7     1[|                                                     ]
	%Cpu1  :   0.8/0.0     1[|                                                     ]
	%Cpu2  : 100.0/0.0   100[||||||||||||||||||||||||||||||||||||||||||||||||||||||]
	%Cpu3  :   0.4/0.0     0[                                                      ]
	MiB Mem :   7973.6 total,   4656.1 free,   1342.8 used,   1974.7 buff/cache
	MiB Swap:   8190.0 total,   8190.0 free,      0.0 used.   6317.6 avail Mem 

	PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                                               
	4529 bateman    1   0 1109096 107880  32372 S   0.0   1.3   0:04.35 node                                                                                  
	4536 bateman    1   0  893108  57100  28360 S   0.0   0.7   0:02.89 node                                                                                  
	5499 bateman    1   0 1110976 111228  32408 S   0.7   1.4   0:02.40 node                                                                                  
	5513 bateman    1   0  892720  55960  28384 S   0.0   0.7   0:02.76 node                                                                                  
	851 bateman    1   0  368356  33040  26008 S   0.0   0.4   0:01.23 nm-applet                                                                             
	31 root       1 -20       0      0      0 I   0.0   0.0   0:00.00 netns                                                                                 
	4705 bateman    1   0    2276    744    680 S   0.0   0.0   0:00.00 myprogramp2                                                                           
	4706 bateman   10  10    2276     80      0 R   3.0   0.0   0:35.88 myprogramp2                                                                           
	4707 bateman   13  10    2276     80      0 R   3.0   0.0  12:25.06 myprogramp2                                                                           
	4708 bateman    6  10    2276     80      0 R   3.3   0.0   0:35.12 myprogramp2                                                                           
	4709 bateman   14  10    2276     80      0 R   3.0   0.0   0:23.67 myprogramp2                                                                           
	4710 bateman    3  10    2276     80      0 R   3.0   0.0   0:23.67 myprogramp2                                                                           
	4711 bateman   25  14    2276     80      0 R   1.7   0.0   0:15.12 myprogramp2                                                                           
	4712 bateman   12  14    2276     80      0 R   1.7   0.0   0:15.10 myprogramp2                                                                           
	4713 bateman   15  14    2276     80      0 R   2.0   0.0   0:15.09 myprogramp2                                                                           
	4714 bateman   18  14    2276     80      0 R   2.0   0.0   0:15.09 myprogramp2                                                                           
	4715 bateman   24  14    2276     80      0 R   2.0   0.0   0:22.26 myprogramp2                                                                           
	4716 bateman    4   0    2276     80      0 R  82.4   0.0  17:30.43 myprogramp2

=================================== P3Q3 end ===================================



================================== P4Q1 start ==================================
Verify Con Kolivas' claim by timing the kernel build-time in both your fallback
and your MuQSS-patched kernels.
    
    muqss time:
		real	5m7.686s
		user	19m9.082s
		sys		2m10.313s
	
	cfs time:
		real	5m13.425s
		user	17m14.517s
		sys	    2m21.756s

muqss kernel has a longer user time but shorter real time, which may means muqss
has a better interaction and better cpu usage.

=================================== P4Q1 end ===================================

================================== P4Q2 start ==================================
Design an experiment that you think will highlight MuQSS’s strength. Perform 
the experiment and report your findings.

We use john-the-ripper in Kolivas’s own benchmarks, which is a cpu intensive work. 
The muqss has slightly better performance, it may because that the muqss uses skiplist
which is simpler than red black tree, and muqss uses try lock which is non-blocking
rather than lock. So muqss has a better cpu usage.

muqss:
	John The Ripper 1.9.0-jumbo-1:
		pts/john-the-ripper-1.7.2 [Test: Blowfish]
		Test 1 of 2
		Estimated Trial Run Count:    3                      
		Estimated Test Run-Time:      17 Minutes             
		Estimated Time To Completion: 33 Minutes [02:49 EST] 
			Started Run 1 @ 02:17:39
			Started Run 2 @ 02:18:13
			Started Run 3 @ 02:22:36

		Test: Blowfish:
			6718
			6685
			6638

		Average: 6680 Real C/S
		Deviation: 0.60%

	John The Ripper 1.9.0-jumbo-1:
		pts/john-the-ripper-1.7.2 [Test: MD5]
		Test 2 of 2
		Estimated Trial Run Count:    3                      
		Estimated Time To Completion: 17 Minutes [02:39 EST] 
			Started Run 1 @ 02:23:17
			Started Run 2 @ 02:24:21
			Started Run 3 @ 02:25:25

		Test: MD5:
			400307
			387584
			385126

		Average: 391006 Real C/S
		Deviation: 2.08%

cfs:
	John The Ripper 1.9.0-jumbo-1:
		pts/john-the-ripper-1.7.2 [Test: Blowfish]
		Test 1 of 2
		Estimated Trial Run Count:    3                      
		Estimated Test Run-Time:      10 Minutes             
		Estimated Time To Completion: 20 Minutes [02:48 EST] 
			Started Run 1 @ 02:28:52
			Started Run 2 @ 02:29:26
			Started Run 3 @ 02:30:00
			Started Run 4 @ 02:30:34 *
			Started Run 5 @ 02:31:09 *
			Started Run 6 @ 02:31:43 *
			Started Run 7 @ 02:32:17 *
			Started Run 8 @ 02:32:51 *
			Started Run 9 @ 02:33:25 *
			Started Run 10 @ 02:33:59 *
			Started Run 11 @ 02:34:33 *
			Started Run 12 @ 02:35:07 *

		Test: Blowfish:
			6435
			5914
			6640
			6624
			6478
			6502
			6404
			6328
			6391
			6447
			6321
			6468

		Average: 6413 Real C/S
		Deviation: 2.89%
		Samples: 12

	John The Ripper 1.9.0-jumbo-1:
		pts/john-the-ripper-1.7.2 [Test: MD5]
		Test 2 of 2
		Estimated Trial Run Count:    3                      
		Estimated Time To Completion: 10 Minutes [02:45 EST] 
			Started Run 1 @ 02:35:54
			Started Run 2 @ 02:36:58
			Started Run 3 @ 02:38:02

		Test: MD5:
			401715
			382592
			382259

		Average: 388855 Real C/S
		Deviation: 2.86%



=================================== P4Q2 end ===================================



================================== P5Q1 start ==================================
Briefly describe the advantages and disadvantages of a larger HZ.

    advantages:
		1. kernel timers would have a better resolution and accuracy.
		2. system calls which have timeout would have a higher accuracy.
		3. measurements as recourses cost and system runtime would have a finer resolution.
		4. higher accuracy of processes' preemption.

	disadvantages:
		1. higher HZ means more time interrupt program in a given time which brings
		heavier workloads to cpu.
		2. higher HZ may also flushes cpu's cache more frequently which leads to
		lower performance.


=================================== P5Q1 end ===================================

================================== P5Q2 start ==================================
What is the HZ currently configured for your running Linux system?

    HZ is 250.
	We craeted a c program named p5.c in user/test/p5. this program include <asm/param.h>
	and print the HZ.

=================================== P5Q2 end ===================================

================================== P5Q3 start ==================================
What are jiffies? Explain the relationship between jiffies, HZ, and time.

    jiffies hold the number of ticks since the system booted. 
	the increment of jiffies a second is HZ, and the system runtime is jiffies/HZ (seconds).

=================================== P5Q3 end ===================================

================================== P5Q4 start ==================================
Find the current value of jiffies in your system.
    - In minutes, how much time does this jiffies value represent?
    - Does it match the uptime reported by the uptime command? (Hint: it 
      doesn’t.) Please give the formula to convert jiffies to the current 
      (real) uptime, in minutes.
    - Why does this large difference exist? (Hint: in 32-bit Linux systems,
      jiffies is a 32-bit value.)

    jiffies is 4297544631
	1. 4297544631 / 250 / 60 = 286502 minutes.
	2. uptime: 176 minutes. so jiffies doesn’t match the uptime.
		formula: (jiffies - (unsigned long)(unsigned int) (-300*HZ)) / HZ / 60 = minutes。
	3. jiffies would be initialized as a 32-bit value (unsigned long)(unsigned int) (-300*HZ), 
	but in 64-bit system, it won't overflow.

=================================== P5Q4 end ===================================

================================== P5Q5 start ==================================
What are Niffies? How do they differ from Jiffies?

    /* TODO */ 

=================================== P5Q5 end ===================================